/*
 * Topotest plugin for the FRR zebra dataplane.
 *
 * Copyright (c) 2020 Volta Networks, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; see the file COPYING; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

/*
 * Should be possible to build this plugin using this sort of command:
 *
 *    gcc -Wall -I ~/work/frr/ -I ~/work/frr/lib -I ~/work/frr/zebra \
 *        -g -O0 -o dplane_test_plugin.so -shared -fPIC dplane_test_plugin.c
 *
 * where 'frr' is a configured and built frr sandbox.
 *
 * Run zebra with '-M /path/to/dplane_test_plugin.so' to load the module.
 */

#define HAVE_CONFIG_H
#include "lib/zebra.h"
#include "lib/libfrr.h"
#include "zebra/zebra_dplane.h"
#include "zebra/debug.h"
#include "lib/nexthop_group_private.h"

static const char *plugin_name = "DPLANE_TEST";

static struct zebra_dplane_provider *prov_p;
static struct thread *backup_test_t;
static struct thread *lsp_test_t;

/* Context objects used to exercise primary/backup nexthop notifications */
static struct zebra_dplane_ctx *backup_ctx;
static struct zebra_dplane_ctx *lsp_ctx;

static void backup_ctx_check(struct zebra_dplane_ctx *ctx);
static int test_route_switchover(struct thread *event);
static int test_route_switch_back(struct thread *event);
static int test_lsp_switchover(struct thread *event);
static int test_lsp_switch_back(struct thread *event);

/* Secs to wait before sending switchover notification */
#define TEST_BACKUP_SWITCH_SECS  30


/*
 * Startup/init callback, called from the dataplane.
 */
static int plugin_start(struct zebra_dplane_provider *prov)
{
	/* Nothing special to do - we don't allocate anything. */
	return 0;
}

/*
 * Shutdown/cleanup callback, called from the main pthread.
 */
static int plugin_fini(struct zebra_dplane_provider *prov, bool early)
{
	if (IS_ZEBRA_DEBUG_DPLANE)
		zlog_debug("test plugin fini called %s",
			   (early ? " (early)": ""));

	if (early) {
		/* Use async form since these are part of the dplane pthread */
		thread_cancel_async(dplane_get_thread_master(), &backup_test_t,
				    NULL);
		thread_cancel_async(dplane_get_thread_master(), &lsp_test_t,
				    NULL);
	} else {
		/* Final shutdown: free backup nexthop and
		 * LSP test info if necessary
		 */
		if (backup_ctx)
			dplane_ctx_fini(&backup_ctx);
		if (lsp_ctx)
			dplane_ctx_fini(&lsp_ctx);
	}

	return 0;
}

/*
 * Callback from the dataplane to process incoming work; this runs in the
 * dplane pthread.
 */
static int plugin_process(struct zebra_dplane_provider *prov)
{
	int counter, limit;
	struct zebra_dplane_ctx *ctx;

	limit = dplane_provider_get_work_limit(prov_p);

	/* Respect the configured limit on the amount of work to do in
	 * any one call.
	 */
	for (counter = 0; counter < limit; counter++) {
		ctx = dplane_provider_dequeue_in_ctx(prov_p);
		if (!ctx)
			break;

		/* Skip updates generated by our own activity */
		if (dplane_ctx_get_notif_provider(ctx) ==
		    dplane_provider_get_id(prov_p))
			goto skip_check;

		/* Examine for backup nexthop test */
		backup_ctx_check(ctx);

skip_check:
		/* Just set 'success' status and return to the dataplane */
		dplane_ctx_set_status(ctx, ZEBRA_DPLANE_REQUEST_SUCCESS);
		dplane_provider_enqueue_out_ctx(prov_p, ctx);
	}

	return 0;
}

/*
 * Init entry point called during zebra startup. This is registered during
 * module init.
 */
static int init_plugin_plugin(struct thread_master *tm)
{
	int ret;

	/* Note that we don't use or store the thread_master 'tm'. We
	 * don't use the zebra main pthread: our plugin code will run in
	 * the zebra dataplane pthread context.
	 */

	/* Register the plugin with the dataplane infrastructure. We
	 * register to be called before the kernel, and we register
	 * our init, process work, and shutdown callbacks.
	 */
	ret = dplane_provider_register(plugin_name, DPLANE_PRIO_PRE_KERNEL,
				       DPLANE_PROV_FLAGS_DEFAULT,
				       plugin_start,
				       plugin_process,
				       plugin_fini,
				       NULL,
				       &prov_p);

	if (IS_ZEBRA_DEBUG_DPLANE)
		zlog_debug("test plugin register => %d", ret);

	return 0;
}

/*
 * If this is a route update for a route that has backup nexthops,
 * capture info about the route, then schedule a timer to notify
 * a primary -> backup nexthop event.
 */
static void backup_ctx_check(struct zebra_dplane_ctx *ctx)
{
	const struct nexthop_group *nhg;
	const struct nhlfe_list_head *nhlfe_list;
	const zebra_nhlfe_t *nhlfe;
	zebra_nhlfe_t *newnh;
	const struct nexthop *nexthop;
	enum dplane_op_e op;

	op = dplane_ctx_get_op(ctx);
	if (op == DPLANE_OP_ROUTE_INSTALL) {
		/* Do we already have a test context ready? */
		if (backup_ctx != NULL)
			goto done;

		nhg = dplane_ctx_get_backup_ng(ctx);
		if (nhg == NULL || nhg->nexthop == NULL)
			goto done;

		/* Allocate our backup context and populate it from the incoming
		 * context.
		 */
		backup_ctx = dplane_ctx_alloc();
		dplane_ctx_set_op(backup_ctx, DPLANE_OP_ROUTE_NOTIFY);
		dplane_ctx_set_afi(backup_ctx, dplane_ctx_get_afi(ctx));
		dplane_ctx_set_safi(backup_ctx, dplane_ctx_get_safi(ctx));
		dplane_ctx_set_vrf(backup_ctx, dplane_ctx_get_vrf(ctx));
		dplane_ctx_set_dest(backup_ctx, dplane_ctx_get_dest(ctx));
		dplane_ctx_set_type(backup_ctx, dplane_ctx_get_type(ctx));
		dplane_ctx_set_table(backup_ctx, dplane_ctx_get_table(ctx));
		dplane_ctx_set_instance(backup_ctx,
					dplane_ctx_get_instance(ctx));
		dplane_ctx_set_nexthops(backup_ctx,
					dplane_ctx_get_ng(ctx)->nexthop);
		dplane_ctx_set_backup_nhg(backup_ctx, nhg);

		/* Set a timer to perform the 'switchover' */
		thread_add_timer(dplane_get_thread_master(),
				 test_route_switchover,
				 NULL, TEST_BACKUP_SWITCH_SECS, &backup_test_t);

	} else if (op == DPLANE_OP_LSP_INSTALL) {
		/* Do we already have an LSP context ready? */
		if (lsp_ctx != NULL)
			goto done;

		nhlfe_list = dplane_ctx_get_backup_nhlfe_list(ctx);
		if (nhlfe_list == NULL)
			goto done;

		/* Make a copy of the context so we can produce a notify
		 * after a short delay.
		 */
		lsp_ctx = dplane_ctx_alloc();
		dplane_ctx_lsp_init(lsp_ctx, DPLANE_OP_LSP_NOTIFY, NULL);
		dplane_ctx_set_in_label(lsp_ctx, dplane_ctx_get_in_label(ctx));
		dplane_ctx_set_type(lsp_ctx, dplane_ctx_get_type(ctx));
		dplane_ctx_set_table(lsp_ctx, dplane_ctx_get_table(ctx));

		nhlfe_list = dplane_ctx_get_nhlfe_list(ctx);
		frr_each(nhlfe_list_const, nhlfe_list, nhlfe) {
			nexthop = nhlfe->nexthop;
			if (nexthop == NULL || nexthop->nh_label == NULL)
				continue;

			newnh = dplane_ctx_add_nhlfe(
				lsp_ctx, nexthop->nh_label_type,
				nexthop->type, &nexthop->gate,
				nexthop->ifindex,
				nexthop->nh_label->num_labels,
				nexthop->nh_label->label);

			/* Must copy extra backup info too */
			if (CHECK_FLAG(nexthop->flags,
				       NEXTHOP_FLAG_HAS_BACKUP)) {
				SET_FLAG(newnh->nexthop->flags,
					 NEXTHOP_FLAG_HAS_BACKUP);
				newnh->nexthop->backup_num=
					nexthop->backup_num;
				memcpy(newnh->nexthop->backup_idx,
				       nexthop->backup_idx,
				       nexthop->backup_num);
			}
		}

		nhlfe_list = dplane_ctx_get_backup_nhlfe_list(ctx);
		frr_each(nhlfe_list_const, nhlfe_list, nhlfe) {
			nexthop = nhlfe->nexthop;
			if (nexthop == NULL || nexthop->nh_label == NULL)
				continue;

			dplane_ctx_add_backup_nhlfe(
				lsp_ctx, nexthop->nh_label_type,
				nexthop->type, &nexthop->gate,
				nexthop->ifindex,
				nexthop->nh_label->num_labels,
				nexthop->nh_label->label);
		}

		/* Set a timer to perform the 'switchover' */
		thread_add_timer(dplane_get_thread_master(),
				 test_lsp_switchover,
				 NULL, TEST_BACKUP_SWITCH_SECS, &lsp_test_t);

	} else
		goto done;

done:

	return;
}

static int test_route_switchover(struct thread *event)
{
	struct nexthop_group *nhg, nhg_temp;
	struct nexthop *nexthop, *nh, *primary;
	int idx = -1, i;
	struct zebra_dplane_ctx *ctx;

	/* Init */
	primary = NULL;
	nhg_temp.nexthop = NULL;

	/* Don't expect this ... */
	if (backup_ctx == NULL)
		goto done;

	zlog_debug("%s: switchover starting", __func__);

	/* Copy the backup context and populate it */
	ctx = dplane_ctx_alloc();
	dplane_ctx_set_op(ctx, DPLANE_OP_ROUTE_NOTIFY);
	dplane_ctx_set_afi(ctx, dplane_ctx_get_afi(backup_ctx));
	dplane_ctx_set_safi(ctx, dplane_ctx_get_safi(backup_ctx));
	dplane_ctx_set_vrf(ctx, dplane_ctx_get_vrf(backup_ctx));
	dplane_ctx_set_dest(ctx, dplane_ctx_get_dest(backup_ctx));
	dplane_ctx_set_type(ctx, dplane_ctx_get_type(backup_ctx));
	dplane_ctx_set_table(ctx, dplane_ctx_get_table(backup_ctx));
	dplane_ctx_set_instance(ctx, dplane_ctx_get_instance(backup_ctx));
	dplane_ctx_set_nexthops(ctx, dplane_ctx_get_ng(backup_ctx)->nexthop);

	/* Look at the primary and backup nexthops and decide which to
	 * 'switchover'.
	 */
	nhg = (struct nexthop_group *)dplane_ctx_get_ng(ctx);

	for (nexthop = nhg->nexthop; nexthop; nexthop = nexthop->next) {
		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
			if (primary == NULL) {
				zlog_debug("%s: switchover for nexthop %pNHv num %d, idx %d)",
					   __func__, nexthop,
					   nexthop->backup_num,
					   nexthop->backup_idx[0]);

				/* Capture the primary and remove it */
				primary = nexthop;

				if (nexthop->prev)
					nexthop->prev->next = nexthop->next;
				if (nexthop->next)
					nexthop->next->prev = nexthop->prev;
				if (nexthop == nhg->nexthop)
					nhg->nexthop = nexthop->next;

				nexthop = primary->next;

				if (nexthop == NULL)
					break;
			}
		}

		/* All others set to installed */
		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
			SET_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB);

		for (nh = nexthop->resolved; nh; nh = nh->next) {
			if (CHECK_FLAG(nh->flags, NEXTHOP_FLAG_ACTIVE))
				SET_FLAG(nh->flags, NEXTHOP_FLAG_FIB);
		}
	}

	/* We do expect to find something */
	if (primary == NULL)
		goto done;

	/* Locate the backup nexthop(s) and set flags */
	nhg = (struct nexthop_group *)dplane_ctx_get_backup_ng(backup_ctx);

	for (i = 0; i < primary->backup_num; i++) {

		idx = 0;
		for (nexthop = nhg->nexthop; nexthop; nexthop = nexthop->next) {
			if (idx == primary->backup_idx[i])
				break;
			idx++;
		}

		if (nexthop == NULL)
			continue;

		zlog_debug("%s: backup nexthop[%d] %pNHv %s",
			   __func__, idx, nexthop,
			   (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE) ?
			    "(recursive)" : ""));

		nh = nexthop_dup(nexthop, NULL);

		/* Enqueue the backup */
		_nexthop_add(&nhg_temp.nexthop, nh);
	}

	/* Now update the flags on the copies of the activated backup(s) */
	for (nexthop = nhg_temp.nexthop; nexthop; nexthop = nexthop->next) {
		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_RECURSIVE)) {
			for (nh = nexthop->resolved; nh; nh = nh->next)
				SET_FLAG(nh->flags, NEXTHOP_FLAG_FIB);
		} else {
			SET_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB);
		}
	}

	/* Attach the backup nhg to the context; this makes a copy of its own */
	dplane_ctx_set_backup_nhg(ctx, &nhg_temp);

	/* Queue the notification for processing */
	dplane_ctx_set_notif_provider(ctx, dplane_provider_get_id(prov_p));
	dplane_provider_enqueue_to_zebra(ctx);
	ctx = NULL;

	/* And start timer for switching back from backup to primary */
	thread_add_timer(dplane_get_thread_master(),
			 test_route_switch_back,
			 NULL, TEST_BACKUP_SWITCH_SECS, &backup_test_t);

done:

	if (primary)
		nexthop_free(primary);

	if (nhg_temp.nexthop)
		nexthops_free(nhg_temp.nexthop);

	/* Clean up if error */
	if (ctx)
		dplane_ctx_fini(&ctx);

	return 0;
}

/* Test switching back from backup to primary */
static int test_route_switch_back(struct thread *event)
{
	struct nexthop_group *nhg;
	struct nexthop *nexthop, *nh;
	struct zebra_dplane_ctx *ctx;

	/* Don't expect this ... */
	if (backup_ctx == NULL)
		goto done;

	zlog_debug("%s: switch back starting", __func__);

	/* Copy the backup context and populate it */
	ctx = dplane_ctx_alloc();
	dplane_ctx_set_op(ctx, DPLANE_OP_ROUTE_NOTIFY);
	dplane_ctx_set_afi(ctx, dplane_ctx_get_afi(backup_ctx));
	dplane_ctx_set_safi(ctx, dplane_ctx_get_safi(backup_ctx));
	dplane_ctx_set_vrf(ctx, dplane_ctx_get_vrf(backup_ctx));
	dplane_ctx_set_dest(ctx, dplane_ctx_get_dest(backup_ctx));
	dplane_ctx_set_type(ctx, dplane_ctx_get_type(backup_ctx));
	dplane_ctx_set_table(ctx, dplane_ctx_get_table(backup_ctx));
	dplane_ctx_set_instance(ctx, dplane_ctx_get_instance(backup_ctx));
	dplane_ctx_set_nexthops(ctx, dplane_ctx_get_ng(backup_ctx)->nexthop);

	/*
	 * Look at the primary nexthops and 'switch back' to use them.
	 */
	nhg = (struct nexthop_group *)dplane_ctx_get_ng(ctx);

	for (nexthop = nhg->nexthop; nexthop; nexthop = nexthop->next) {

		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_ACTIVE))
			SET_FLAG(nexthop->flags, NEXTHOP_FLAG_FIB);

		for (nh = nexthop->resolved; nh; nh = nh->next) {
			if (CHECK_FLAG(nh->flags, NEXTHOP_FLAG_ACTIVE))
				SET_FLAG(nh->flags, NEXTHOP_FLAG_FIB);
		}
	}

	/* Send no backups in the notification */

	/* Queue the notification for processing */
	dplane_ctx_set_notif_provider(ctx, dplane_provider_get_id(prov_p));
	dplane_provider_enqueue_to_zebra(ctx);

	ctx = NULL;
done:

	/* Clean up if error */
	if (ctx)
		dplane_ctx_fini(&ctx);

	if (backup_ctx)
		dplane_ctx_fini(&backup_ctx);

	return 0;
}

/* Test switching LSP to a backup nhlfe */
static int test_lsp_switchover(struct thread *event)
{
	struct zebra_dplane_ctx *ctx;
	struct nexthop *nexthop;
	const zebra_nhlfe_t *nhlfe;
	zebra_nhlfe_t *newnh;
	const struct nhlfe_list_head *list_head;
	int idx = -1, i;
	const struct nexthop *primary;

	/* Don't expect this ... */
	if (lsp_ctx == NULL)
		goto done;

	zlog_debug("%s: LSP switchover starting", __func__);

	/* Make a copy of the context we captured so we can modify it.
	 */
	ctx = dplane_ctx_alloc();
	dplane_ctx_lsp_init(ctx, DPLANE_OP_LSP_NOTIFY, NULL);
	dplane_ctx_set_in_label(ctx, dplane_ctx_get_in_label(lsp_ctx));
	dplane_ctx_set_type(ctx, dplane_ctx_get_type(lsp_ctx));
	dplane_ctx_set_table(ctx, dplane_ctx_get_table(lsp_ctx));

	primary = NULL;

	/* Find the first nhlfe with a backup */
	list_head = dplane_ctx_get_nhlfe_list(lsp_ctx);
	frr_each(nhlfe_list_const, list_head, nhlfe) {
		nexthop = nhlfe->nexthop;
		if (nexthop == NULL || nexthop->nh_label == NULL)
			continue;

		newnh = dplane_ctx_add_nhlfe(ctx, nexthop->nh_label_type,
					     nexthop->type, &nexthop->gate,
					     nexthop->ifindex,
					     nexthop->nh_label->num_labels,
					     nexthop->nh_label->label);

		/* Capture the first backup index; set that nhlfe as
		 * not-installed.
		 */
		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {

			/* Must copy this additional info; not captured
			 * otherwise.
			 */
			SET_FLAG(newnh->nexthop->flags,
				 NEXTHOP_FLAG_HAS_BACKUP);
			newnh->nexthop->backup_num = nexthop->backup_num;
			memcpy(newnh->nexthop->backup_idx,
			       nexthop->backup_idx,
			       nexthop->backup_num);

			if (primary == NULL) {
				zlog_debug("%s: switchover for nhlfe %pNHv",
					   __func__, nexthop);

				primary = nexthop;

				UNSET_FLAG(newnh->flags, NHLFE_FLAG_INSTALLED);
				UNSET_FLAG(newnh->nexthop->flags,
					   NEXTHOP_FLAG_FIB);

				continue;
			}
		}

		zlog_debug("%s: add primary nhlfe %pNHv",
			   __func__, nexthop);

		/* All other nhlfes are set to installed status */
		SET_FLAG(newnh->flags, NHLFE_FLAG_INSTALLED);
		SET_FLAG(newnh->nexthop->flags, NEXTHOP_FLAG_FIB);
	}

	/* We expect to have found an nhlfe with a backup */
	if (primary == NULL)
		goto done;

	/* Copy backup nhlfes, then set the one(s) associated with
	 * 'primary' to installed status.
	 */
	idx = 0;
	list_head = dplane_ctx_get_backup_nhlfe_list(lsp_ctx);
	frr_each(nhlfe_list_const, list_head, nhlfe) {
		nexthop = nhlfe->nexthop;
		if (nexthop == NULL || nexthop->nh_label == NULL)
			continue;

		zlog_debug("%s: add backup nhlfe %pNHv",
			   __func__, nexthop);

		newnh = dplane_ctx_add_backup_nhlfe(
			ctx, nexthop->nh_label_type,
			nexthop->type, &nexthop->gate,
			nexthop->ifindex,
			nexthop->nh_label->num_labels,
			nexthop->nh_label->label);

		for (i = 0; i < primary->backup_num; i++) {
			if (primary->backup_idx[i] == idx) {
				SET_FLAG(newnh->flags, NHLFE_FLAG_INSTALLED);
				SET_FLAG(newnh->nexthop->flags,
					 NEXTHOP_FLAG_FIB);
				break;
			}
		}

		idx++;
	}

	/* Queue the notification for processing */
	dplane_ctx_set_notif_provider(ctx, dplane_provider_get_id(prov_p));
	dplane_provider_enqueue_to_zebra(ctx);
	ctx = NULL;

	/* Set another timer to perform the 'switch back' */
	thread_add_timer(dplane_get_thread_master(),
			 test_lsp_switch_back,
			 NULL, TEST_BACKUP_SWITCH_SECS, &lsp_test_t);

done:

	/* Clean up if error */
	if (ctx)
		dplane_ctx_fini(&ctx);

	return 0;
}

/* Test switching LSP back from a backup nhlfe to the original nhlfe */
static int test_lsp_switch_back(struct thread *event)
{
	struct zebra_dplane_ctx *ctx;
	struct nexthop *nexthop;
	const zebra_nhlfe_t *nhlfe;
	zebra_nhlfe_t *newnh;
	const struct nhlfe_list_head *list_head;

	/* Don't expect this ... */
	if (lsp_ctx == NULL)
		goto done;

	zlog_debug("%s: LSP switchback starting", __func__);

	/* Make a copy of the context we captured so we can create
	 * a notification from it.
	 */
	ctx = dplane_ctx_alloc();
	dplane_ctx_lsp_init(ctx, DPLANE_OP_LSP_NOTIFY, NULL);
	dplane_ctx_set_in_label(ctx, dplane_ctx_get_in_label(lsp_ctx));
	dplane_ctx_set_type(ctx, dplane_ctx_get_type(lsp_ctx));
	dplane_ctx_set_table(ctx, dplane_ctx_get_table(lsp_ctx));

	/* Copy primary nhlfes */
	list_head = dplane_ctx_get_nhlfe_list(lsp_ctx);
	frr_each(nhlfe_list_const, list_head, nhlfe) {
		nexthop = nhlfe->nexthop;
		if (nexthop == NULL || nexthop->nh_label == NULL)
			continue;

		zlog_debug("%s: add primary nhlfe %pNHv",
			   __func__, nexthop);

		newnh = dplane_ctx_add_nhlfe(ctx, nexthop->nh_label_type,
					     nexthop->type, &nexthop->gate,
					     nexthop->ifindex,
					     nexthop->nh_label->num_labels,
					     nexthop->nh_label->label);

		if (CHECK_FLAG(nexthop->flags, NEXTHOP_FLAG_HAS_BACKUP)) {
			/*
			 * Must copy this additional info; not captured
			 * otherwise.
			 */
			SET_FLAG(newnh->nexthop->flags,
				 NEXTHOP_FLAG_HAS_BACKUP);
			newnh->nexthop->backup_num = nexthop->backup_num;
			memcpy(newnh->nexthop->backup_idx,
			       nexthop->backup_idx,
			       nexthop->backup_num);
		}

		/* All primary nhlfes are set to installed status */
		SET_FLAG(newnh->flags, NHLFE_FLAG_INSTALLED);
		SET_FLAG(newnh->nexthop->flags, NEXTHOP_FLAG_ACTIVE);
		SET_FLAG(newnh->nexthop->flags, NEXTHOP_FLAG_FIB);
	}

	/* Copy backup nhlfes */
	list_head = dplane_ctx_get_backup_nhlfe_list(lsp_ctx);
	frr_each(nhlfe_list_const, list_head, nhlfe) {
		nexthop = nhlfe->nexthop;
		if (nexthop == NULL || nexthop->nh_label == NULL)
			continue;

		zlog_debug("%s: add backup nhlfe %pNHv",
			   __func__, nexthop);

		newnh = dplane_ctx_add_backup_nhlfe(
			ctx, nexthop->nh_label_type,
			nexthop->type, &nexthop->gate,
			nexthop->ifindex,
			nexthop->nh_label->num_labels,
			nexthop->nh_label->label);
	}

	/* Queue the notification for processing */
	dplane_ctx_set_notif_provider(ctx, dplane_provider_get_id(prov_p));
	dplane_provider_enqueue_to_zebra(ctx);
	ctx = NULL;

done:

	/* Clean up if error */
	if (ctx)
		dplane_ctx_fini(&ctx);

	/* Clean up original context copy */
	if (lsp_ctx)
		dplane_ctx_fini(&lsp_ctx);

	return 0;
}

/*
 * Base FRR loadable module info: basic info including module entry-point.
 */
static int module_init(void)
{
	hook_register(frr_late_init, init_plugin_plugin);
	return 0;
}

FRR_MODULE_SETUP(
	.name = "dplane_test",
	.version = "0.0.1",
	.description = "Dplane Test Plugin",
	.init = module_init,
	)
